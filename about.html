<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>About Me - Nicholas Bratvold</title>
  <link rel="stylesheet" href="style.css">
  <script type="importmap">
    {
      "imports": {
      "three": "https://unpkg.com/three@0.122.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.122.0/examples/jsm/"
      }
    }
    </script>
    <script src="js/KeyboardState.js"></script>
</head>
<body>

  <header>
    <h1>Nicholas Bratvold</h1>
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="projects.html">Projects</a></li>
        <li><a href="resume.html">Resume</a></li>
      </ul>
    </nav>
  </header>
  <div id="canvas"></div>
  <section>
    <h2>About Me</h2>
    <p>Your introduction and details about yourself go here.</p>
  </section>
  <script id="myVertShader" type="x-shader/x-vertex">
    uniform vec2 uvScale;
    varying vec2 vUv;
    varying vec3 vcsNormal;
    varying vec3 ocsPosition;
    varying vec3 vcsPosition;
    void main()
    {       
      vUv = uvScale * uv;
      ocsPosition = position;
      vec4 vcsP = modelViewMatrix * vec4(ocsPosition,1.0);
      vcsPosition = vcsP.xyz;
      gl_Position = projectionMatrix * vcsP;   // pass on point in CCS
      vcsNormal = normalMatrix * normal;       // normalMatrix is the transpose-inv of the rotation matrix
    }
  </script>

  <script id="pnoiseFragShader" type="x-shader/x-fragment">
    float screenWidth = 2.0;
    float PI = 3.1416;
    uniform float time;
    // perlin noise code from: 
    //   https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
    
    float rand(vec2 c){
      return fract(sin(dot(c.xy ,vec2(45.9798,78.233))) * 10753.5453);
    }
    
    float noise(vec2 p, float freq ){
      float unit = screenWidth/freq;
      vec2 ij = floor(p/unit);
      vec2 xy = mod(p,unit)/unit;
      //xy = 3.*xy*xy-2.*xy*xy*xy;
      xy = .5*(1.-cos(PI*xy));
      float a = rand((ij+vec2(0.,0.)));
      float b = rand((ij+vec2(1.,0.)));
      float c = rand((ij+vec2(0.,1.)));
      float d = rand((ij+vec2(1.,1.)));
      float x1 = mix(a, b, xy.x);
      float x2 = mix(c, d, xy.x);
      return mix(x1, x2, xy.y);
    }
    
    float pNoise(vec2 p, int res){
      float persistance = .7;
      float n = 0.;
      float normK = 0.;
      float f = 2.;
      float amp = 2.;
      int iCount = 0;
      for (int i = 0; i<100; i++){
        n+=amp*noise(p, f) + sin(time/10.);
        f*=2.;
        normK+=amp;
        amp*=persistance;
        if (iCount == res) break;
        iCount++;
      }
      float nf = n/normK;
      return nf*nf*nf*nf;
    }
    //Computes pNoise(p + (Pnoise(),PNoise())) for warping effect : https://iquilezles.org/articles/warp/
    float pattern(vec2 p, out vec4 ron, int level){
      vec2 q = vec2( pNoise(p, level), pNoise(p, level-1));
      ron = vec4(p*0.2, q*0.2);
      return pNoise(p + 1.0*q, level);
    }
    
    varying vec3 ocsPosition;
    varying vec3 vcsPosition;
    void main( void ) {
      int levels = 2;
      vec2 p = ocsPosition.xy;
      vec4 on = vec4(0.0);
      float f = pattern(ocsPosition.xy, on, levels);
      vec3 colour = vec3(0.0);

      // Adjusting color vectors for earthy tones with more red
      colour = mix( vec3(0.1, 0.3, 0.0), vec3(0.6, 0.4, 0.3), f );
      colour = mix( colour, vec3(0.4, 0.3, 0.0), dot(on.zw, on.zw) );
      colour = mix( colour, vec3(0.9, 0.1, 0.0), 0.1 + 0.2 * on.y * on.y );
      colour = mix( colour, vec3(0.4, 0.2, 0.1), 0.5 * smoothstep(1.2, 1.5, abs(on.z) + abs(on.w)) );
      colour = clamp( colour * f * 2.0, 0.0, 1.0 );

      // Manual derivatives - better quality, but slower
      vec4 kk;
      float e = 0.00001;
      vec3 nor = normalize( vec3( pattern(p + vec2(e, 0.0), kk, levels) - f,
                                  2.0 * e,
                                  pattern(p + vec2(0.0, e), kk, levels) - f ) );

      vec3 lig = normalize( vec3(0.9, 0.2, -0.9) );
      float dif = clamp( 0.3 + 0.7 * dot( nor, lig ), 0.0, 1.0 );
      vec3 lin = vec3(0.65, 0.9, 0.95) * (nor.y * 0.5 + 0.5) + vec3(0.15, 0.10, 0.05) * dif;
      colour *= 1.1 * lin;
      colour = 1.0 - colour;
      colour = 0.6 * colour * colour;
      gl_FragColor = vec4(colour, 0.8);
  }
    </script>
  <script type="module" src="js/wavy.js"></script>
</body>
</html>